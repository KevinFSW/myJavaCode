修饰符
    权限修饰符
        public         公共的    本类  同包  子类（同一工程任何地方）
        protected      受保护的  本类  同包  子类（通过子类在子类内部访问）
        默认不写        默认的    本类  同包  
        private        私有的    本类  

        权限修饰符可以修饰类和类中的成员（除了程序块）

        java类和类之间的关系：继承  关联  依赖
        Java面向对象的四个特征：继承  封装  多态  （抽象）

        封装：将一些数据或执行过程进行包装
        目的：保护这些数据和过程的安全

    特征修饰符
        final          做终的 不可改变的  
            修饰基本数据类型，值不可改变（也就是常量），修饰引用数据类型，其地址引用不可改变
            修饰基本数据类型，定义时允许不赋初值，但只能赋值一次，修饰引用数据类型，定义时必须赋初值
            修饰方法，则方法不可以再重写 
            修饰类，不可再被继承
            
        static         静态的
            可以修饰方法，属性，程序块，内部类
            静态成员在类加载的时候就初始化了，此时还没有创建对象
            静态成员存在静态元素区中
            静态成员在内存中只有一份，创建的对象共享同一个静态成员
            静态元素区不能被GC（垃圾回收器）管理，可以认为静态成员常驻内存
            可以理解为静态成员属于类，而不是对象
            静态成员中不可以访问非静态成员（可能当前根本就没有创建对象）
            静态成员中不能出现this或super（因为静态成员属于类，而不是对象）
            
        类的加载过程
            1、加载父类
            2、父类会产生自己的静态空间 属性 方法 块
                执行静态块
            3、加载子类
            4、子类会产生自己的静态空间 属性 方法 块
                执行静态块
            5、开辟对象空间
            6、加载父类的非静态成员 属性 方法 块 构造方法
            7、执行块 执行父类的构造方法
            8、加载子类的非静态成员 属性 方法 块 构造方法
            9、执行块 执行子类的构造方法
            10、将对象空间的地址引用交给变量来存储

        abstract       抽象的
            修饰方法
                抽象方法必须放在抽象类或者接口中
            修饰类
                抽象类中可以没有抽象方法
                抽象类中可以含有一般属性、方法（包括private  static  final）、块（包括static）和构造方法，独有的：允许含有抽象方法
                不能直接调用抽象类的构造方法创建该类的对象，只能通过子类继承来间接创建对象
                抽象类可以直接单继承抽象类
                抽象类可以直接单继承具体类
                具体类不可以直接单继承抽象类（需要让具体类将抽象方法重写，具体化）
                抽象类中可以没有抽象方法
                抽象类中可以没有具体成员

            接口interface的特点
                1、含有成员：属性（只能是共有的静态的常量  public static final）
                            方法（只能含有共有的抽象的方法。1.8版本之后可以用default来修饰具体方法）
                            不能有块（没有一般块，也没有静态块）
                            没有构造方法
                2、如何使用：接口没有构造方法，只能通过子类多实现（implement）接口来做事情
                3、接口与接口。接口与类的关系
                    接口不能继承其他类，抽象类和具体类都不行
                    接口可以直接多继承接口
                    抽象类可以直接多实现接口
                    具体类不可以直接多实现接口（需要将接口中的抽象方法重写具体化，否则该子类也需要写成抽象类）

        native         本地的
        *transient     瞬时的 短暂的 ------> 序列化
        *synchronized  同步的 线程的问题才会用到
        *volatile      不稳定的

    设计模式（经验的总结，是一种通用的解决方案）
        创建型模式5种 -----> 用于解决创建对象的过程
            单例模式  工厂方法模式  抽象工厂模式  建造者模式  原型模式  
        结构型模式7种 -----> 吧类或对象通过某种形式结合在一起，构成某种复杂或者合理的结构
            适配器模式  装饰模式  代理模式  外观模式  桥接模式  组合模式  享元模式 
        行为型模式11种 ----> 用来解决类或对象之间的交互 更合理的优化类或者对象之间的关系
            观察者模式  策略模式  模板模式  责任链模式  解析器模式  迭代子模式  命令模式
            状态模式  备忘录模式  访问者模式  中介者模式

        单例模式（singleton）
            设计--->一个类只能创建一个对象
                先避免外部直接调用类的构造方法 private ----> 私有的构造方法
                用静态的当前类对象的属性 ----> 私有的静态的当前类对象作为属性
                不需要创建对象就能调用方法获得创建的对象 ----> 静态方法返回唯一的对象