        单例模式（singleton）
            设计--->一个类只能创建一个对象
                先避免外部直接调用类的构造方法 private ----> 私有的构造方法
                用静态的当前类对象的属性 ----> 私有的静态的当前类对象作为属性
                不需要创建对象就能调用方法获得创建的对象 ----> 静态方法返回唯一的对象
        
        适配器模式之缺省适配器模式：
            解决一个接口（规则）定义了很多方法，实现接口之后，如果修改接口，需要把所有实现这个接口的类都做修改
            创建一个抽象的类作为中介，把新添加的方法添加到这个中介里
            每个子类继承这个抽象类，实现接口所有的方法


    Java面向对象的四个特征：继承  封装  多态  （抽象）
        多态：同一个对象体现多种不同的形态（身份），将一种行为变现出不同的效果
        想要实现多态的效果，需要先有继承关系
        体现：
            1、父类的引用指向子类的对象
            2、该引用只能使用父类中定义的方法和属性
            3、如果子类重写了方法，那么父类的引用调用的是子类重写的方法
            4、如果子类与父类有同名的属性，则执行父类的属性
            5、如果想要调用子类中的独有成员，需要（强制类型转换）造型（铸型、向上/向下转型）
            6、若造型的类型不匹配，会产生一个运行时异常ClassCastException
            7、为了避免上述异常，可以利用instanceof进行判断 a instanceof b

        练习：银行bank，设计一个方法 等待客户来办理业务
            profession：取号排队    办理业务   结束离开

        引申：策略模式  解决同一流程，因不同的策略产生不同的结果
            提供抽象的策略，传递子类的对象（实际的策略）

    
    内部类：
        *1、成员内部类
            将一个类直接定义在类里面作为成员，与属性和方法层次一致
            外部类.内部类 xxx = 外部类对象.new 内部类构造方法
            要在内部类调用外部类的成员 外部类.this.外部类的成员
            编译后的文件 外部类$内部类.class
        2、局部内部类
            将一个类定义在方法或者块里面，作为成员的内部结构，与临时的局部变量同一个层次，因此不能使用权限修饰符修饰，特征修饰符只能使用abstract或final
            局部内部类使用的变量只能是final修饰
        *3、匿名内部类
            成员匿名内部类
            局部匿名内部类
            public interface Test{
                public void test();
            }
            Test t = new Test(){
                public void test(){

                }
            }

            通常接口或者抽象类的具体子类这样写
            开发中为了省略一个类文件，上述写法比较常见
            匿名内部类很特殊，只有类体，没有类的所有结构（修饰符 名字 继承 实现）
            不能用任何的修饰符来修饰， 匿名内部类也没有构造方法

        4、静态内部类
            成员静态内部类
            不需要外部类对象，通过正常的方式直接创建内部类
            public static class
            静态元素不能访问非静态元成员（自己类和外部类都不行）





            