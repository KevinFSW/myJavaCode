按操作数的数目分类

　　单目a++
    双目a+b
　　三目a>b?x:y;

按功能分类

算术运算

    加减乘除，% ++ --

赋值运算

    =  +=  -=  *=  /=  %=

    整型常量在内存中默认占用 32bit（int）
    浮点型常量在内存中默认占用 64bit（double）

    ++x先自增再备份，x++先备份再自加
    int b = 1;
    执行b = b++;后，b = 1;因为b++之前会先备份，因此b实际上是等于b的备份，而非b自增后的值。
    变量运算之前，会先备份。

　　变量与常量做运算，变量会先转换成常量的类型，因此计算完成后，在赋值过程中可能会存在损失问题，例：
　　byte x = 1;
　　x += 1;//此处不会报错
　　x = x + 1;//此处会报错

比较运算符
　　== （对象用instanceof类）

　　比较运算符，比较的结果是boolean

逻辑运算
    &与  | 或  
    &&短路与   前面的结果为FALSE时短路，不再判断后面的结果
    || 短路或    前面的结果为TRUE时短路，不再判断后面的结果
　　^逻辑异或
　　逻辑运算符前后连接的应该是两个boolean型的结果

位（bit）运算
    &按位与   | 按位或   ^按位异或   ～按位取反（单目运算）   
    <<按位左移  >>按位右移
    对于负数  >>保留符号位   >>>高位补0
    
原码 反码 补码
          6           -6
原码  0000 0110   1000 0110
反码  0000 0110   1111 1001（符号位不变，其他位取反）
补码  0000 0110   1111 1010（反码+1）

    计算机中正负数都是用补码存储的

    取反  (0;-1)   (1;-2)   (2;-3)，6取反为-7

    -1 ----> 1111 1111 1111 1111 1111 1111 1111 1111
    -2 ----> 1111 1111 1111 1111 1111 1111 1111 1110   (-1-1)
    -3 ----> 1111 1111 1111 1111 1111 1111 1111 1101   (-2-1)

    可以使用位移实现部分乘除运算
    
    int a = 1;//不通过中间变量实现值交换
    int b = 2;
    ——————————————
    //容易导致越界
    a = a+b;
    b = a-b;
    a = a-b;
    ——————————————
    //不容易导致越界
    a = a^b;
    b = a^b;
    a = a^b;

    每个运算符的优先级

    

